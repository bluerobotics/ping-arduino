// C++ implementation of the Blue Robotics 'Ping' binary message protocol

//~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!
// THIS IS AN AUTOGENERATED FILE
// DO NOT EDIT
//~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!

#pragma once

#include "ping-message.h"

// TODO: should maybe be an enum
namespace CommonId
{
    static const uint16_t ACK = 1;
    static const uint16_t NACK = 2;
    static const uint16_t ASCII_TEXT = 3;
    static const uint16_t GENERAL_REQUEST = 6;
    static const uint16_t DEVICE_INFORMATION = 4;
    static const uint16_t PROTOCOL_VERSION = 5;
}

class common_ack : public ping_message
{
public:
    common_ack(const ping_message& msg) : ping_message { msg } {}
    common_ack(const uint8_t* buf, const uint16_t length) : ping_message { buf, length } {}
    common_ack() : ping_message { static_cast<uint16_t>(12) }
    {
        msgData[0] = 'B';
        msgData[1] = 'R';
        reinterpret_cast<uint16_t&>(msgData[2]) = static_cast<uint16_t>(2); // payload size
        reinterpret_cast<uint16_t&>(msgData[4]) = 1; // ID
        msgData[6] = 0;
        msgData[7] = 0;
    }

    uint16_t acked_id() const { return reinterpret_cast<uint16_t&>(msgData[headerLength + 0]); }
    void set_acked_id(const uint16_t acked_id) { reinterpret_cast<uint16_t&>(msgData[headerLength + 0]) = acked_id; }

    int getMessageAsString(char* string, size_t size) const {
        int written = ping_message::getMessageAsString(string, size);
        if (written > 0 && written < static_cast<int>(size)) {
            return snprintf(string + written, size - static_cast<size_t>(written),
                "  acked_id: %d\n"
                , acked_id()
            );
        }
        return written;
    }
};

class common_nack : public ping_message
{
public:
    common_nack(const ping_message& msg) : ping_message { msg } {}
    common_nack(const uint8_t* buf, const uint16_t length) : ping_message { buf, length } {}
    common_nack(uint16_t nack_message_length) : ping_message { static_cast<uint16_t>(12 + nack_message_length) }
    {
        msgData[0] = 'B';
        msgData[1] = 'R';
        reinterpret_cast<uint16_t&>(msgData[2]) = static_cast<uint16_t>(2 + nack_message_length); // payload size
        reinterpret_cast<uint16_t&>(msgData[4]) = 2; // ID
        msgData[6] = 0;
        msgData[7] = 0;
    }

    uint16_t nacked_id() const { return reinterpret_cast<uint16_t&>(msgData[headerLength + 0]); }
    void set_nacked_id(const uint16_t nacked_id) { reinterpret_cast<uint16_t&>(msgData[headerLength + 0]) = nacked_id; }
    char* nack_message() const { return reinterpret_cast<char*>(msgData+headerLength+2); }
    void set_nack_message_at(const uint16_t i, const char data) { reinterpret_cast<char&>(msgData[headerLength + 2 + i]) = data; }

    int getMessageAsString(char* string, size_t size) const {
        int written = ping_message::getMessageAsString(string, size);
        if (written > 0 && written < static_cast<int>(size)) {
            return snprintf(string + written, size - static_cast<size_t>(written),
                "  nacked_id: %d\n"
                "  nack_message: %s\n"
                , nacked_id()
                , nack_message()
            );
        }
        return written;
    }
};

class common_ascii_text : public ping_message
{
public:
    common_ascii_text(const ping_message& msg) : ping_message { msg } {}
    common_ascii_text(const uint8_t* buf, const uint16_t length) : ping_message { buf, length } {}
    common_ascii_text(uint16_t ascii_message_length) : ping_message { static_cast<uint16_t>(10 + ascii_message_length) }
    {
        msgData[0] = 'B';
        msgData[1] = 'R';
        reinterpret_cast<uint16_t&>(msgData[2]) = static_cast<uint16_t>(0 + ascii_message_length); // payload size
        reinterpret_cast<uint16_t&>(msgData[4]) = 3; // ID
        msgData[6] = 0;
        msgData[7] = 0;
    }

    char* ascii_message() const { return reinterpret_cast<char*>(msgData+headerLength+0); }
    void set_ascii_message_at(const uint16_t i, const char data) { reinterpret_cast<char&>(msgData[headerLength + 0 + i]) = data; }

    int getMessageAsString(char* string, size_t size) const {
        int written = ping_message::getMessageAsString(string, size);
        if (written > 0 && written < static_cast<int>(size)) {
            return snprintf(string + written, size - static_cast<size_t>(written),
                "  ascii_message: %s\n"
                , ascii_message()
            );
        }
        return written;
    }
};

class common_general_request : public ping_message
{
public:
    common_general_request(const ping_message& msg) : ping_message { msg } {}
    common_general_request(const uint8_t* buf, const uint16_t length) : ping_message { buf, length } {}
    common_general_request() : ping_message { static_cast<uint16_t>(12) }
    {
        msgData[0] = 'B';
        msgData[1] = 'R';
        reinterpret_cast<uint16_t&>(msgData[2]) = static_cast<uint16_t>(2); // payload size
        reinterpret_cast<uint16_t&>(msgData[4]) = 6; // ID
        msgData[6] = 0;
        msgData[7] = 0;
    }

    uint16_t requested_id() const { return reinterpret_cast<uint16_t&>(msgData[headerLength + 0]); }
    void set_requested_id(const uint16_t requested_id) { reinterpret_cast<uint16_t&>(msgData[headerLength + 0]) = requested_id; }

    int getMessageAsString(char* string, size_t size) const {
        int written = ping_message::getMessageAsString(string, size);
        if (written > 0 && written < static_cast<int>(size)) {
            return snprintf(string + written, size - static_cast<size_t>(written),
                "  requested_id: %d\n"
                , requested_id()
            );
        }
        return written;
    }
};

class common_device_information : public ping_message
{
public:
    common_device_information(const ping_message& msg) : ping_message { msg } {}
    common_device_information(const uint8_t* buf, const uint16_t length) : ping_message { buf, length } {}
    common_device_information() : ping_message { static_cast<uint16_t>(16) }
    {
        msgData[0] = 'B';
        msgData[1] = 'R';
        reinterpret_cast<uint16_t&>(msgData[2]) = static_cast<uint16_t>(6); // payload size
        reinterpret_cast<uint16_t&>(msgData[4]) = 4; // ID
        msgData[6] = 0;
        msgData[7] = 0;
    }

    uint8_t device_type() const { return reinterpret_cast<uint8_t&>(msgData[headerLength + 0]); }
    void set_device_type(const uint8_t device_type) { reinterpret_cast<uint8_t&>(msgData[headerLength + 0]) = device_type; }
    uint8_t device_revision() const { return reinterpret_cast<uint8_t&>(msgData[headerLength + 1]); }
    void set_device_revision(const uint8_t device_revision) { reinterpret_cast<uint8_t&>(msgData[headerLength + 1]) = device_revision; }
    uint8_t firmware_version_major() const { return reinterpret_cast<uint8_t&>(msgData[headerLength + 2]); }
    void set_firmware_version_major(const uint8_t firmware_version_major) { reinterpret_cast<uint8_t&>(msgData[headerLength + 2]) = firmware_version_major; }
    uint8_t firmware_version_minor() const { return reinterpret_cast<uint8_t&>(msgData[headerLength + 3]); }
    void set_firmware_version_minor(const uint8_t firmware_version_minor) { reinterpret_cast<uint8_t&>(msgData[headerLength + 3]) = firmware_version_minor; }
    uint8_t firmware_version_patch() const { return reinterpret_cast<uint8_t&>(msgData[headerLength + 4]); }
    void set_firmware_version_patch(const uint8_t firmware_version_patch) { reinterpret_cast<uint8_t&>(msgData[headerLength + 4]) = firmware_version_patch; }
    uint8_t reserved() const { return reinterpret_cast<uint8_t&>(msgData[headerLength + 5]); }
    void set_reserved(const uint8_t reserved) { reinterpret_cast<uint8_t&>(msgData[headerLength + 5]) = reserved; }

    int getMessageAsString(char* string, size_t size) const {
        int written = ping_message::getMessageAsString(string, size);
        if (written > 0 && written < static_cast<int>(size)) {
            return snprintf(string + written, size - static_cast<size_t>(written),
                "  device_type: %d\n"
                "  device_revision: %d\n"
                "  firmware_version_major: %d\n"
                "  firmware_version_minor: %d\n"
                "  firmware_version_patch: %d\n"
                "  reserved: %d\n"
                , device_type()
                , device_revision()
                , firmware_version_major()
                , firmware_version_minor()
                , firmware_version_patch()
                , reserved()
            );
        }
        return written;
    }
};

class common_protocol_version : public ping_message
{
public:
    common_protocol_version(const ping_message& msg) : ping_message { msg } {}
    common_protocol_version(const uint8_t* buf, const uint16_t length) : ping_message { buf, length } {}
    common_protocol_version() : ping_message { static_cast<uint16_t>(14) }
    {
        msgData[0] = 'B';
        msgData[1] = 'R';
        reinterpret_cast<uint16_t&>(msgData[2]) = static_cast<uint16_t>(4); // payload size
        reinterpret_cast<uint16_t&>(msgData[4]) = 5; // ID
        msgData[6] = 0;
        msgData[7] = 0;
    }

    uint8_t version_major() const { return reinterpret_cast<uint8_t&>(msgData[headerLength + 0]); }
    void set_version_major(const uint8_t version_major) { reinterpret_cast<uint8_t&>(msgData[headerLength + 0]) = version_major; }
    uint8_t version_minor() const { return reinterpret_cast<uint8_t&>(msgData[headerLength + 1]); }
    void set_version_minor(const uint8_t version_minor) { reinterpret_cast<uint8_t&>(msgData[headerLength + 1]) = version_minor; }
    uint8_t version_patch() const { return reinterpret_cast<uint8_t&>(msgData[headerLength + 2]); }
    void set_version_patch(const uint8_t version_patch) { reinterpret_cast<uint8_t&>(msgData[headerLength + 2]) = version_patch; }
    uint8_t reserved() const { return reinterpret_cast<uint8_t&>(msgData[headerLength + 3]); }
    void set_reserved(const uint8_t reserved) { reinterpret_cast<uint8_t&>(msgData[headerLength + 3]) = reserved; }

    int getMessageAsString(char* string, size_t size) const {
        int written = ping_message::getMessageAsString(string, size);
        if (written > 0 && written < static_cast<int>(size)) {
            return snprintf(string + written, size - static_cast<size_t>(written),
                "  version_major: %d\n"
                "  version_minor: %d\n"
                "  version_patch: %d\n"
                "  reserved: %d\n"
                , version_major()
                , version_minor()
                , version_patch()
                , reserved()
            );
        }
        return written;
    }
};

