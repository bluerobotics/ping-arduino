/*
* ping1d.cpp
* A device API for the Blue Robotics Ping1D echosounder
*
*~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!
* THIS IS AN AUTOGENERATED FILE
* DO NOT EDIT
*~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!
*
*/

#include "ping1d.h"
#include "ping-message-all.h"
#include "ping-message-ping1d.h"

Ping1D::Ping1D(Stream& ser) : _stream ( ser ) {}

Ping1D::~Ping1D()
{
    if (_profile_data) {
       free(_profile_data);
    }
}

ping_message* Ping1D::read()
{
    while(_stream.available()) {
        if (_parser.parseByte(_stream.read()) == PingParser::State::NEW_MESSAGE) {
          return &_parser.rxMessage;
        }
    }
    return nullptr;
}

size_t Ping1D::write(uint8_t* data, uint16_t length)
{
    return _stream.write(data, length);
}

bool Ping1D::initialize(uint16_t ping_interval_ms)
{
    // allow 'auto' firmware to detect baudrate
    _stream.write(0b01010101);

    if(!request(PingMessageId::PING1D_DEVICE_ID)) {
        return false;
    }

    if (!request(PingMessageId::PING1D_FIRMWARE_VERSION)) {
        return false;
    }

    if(!request(PingMessageId::PING1D_VOLTAGE_5)) {
        return false;
    }

    if (!request(PingMessageId::PING1D_PROCESSOR_TEMPERATURE)) {
        return false;
    }

    // Configure ping interval
    if (!set_ping_interval(ping_interval_ms)) {
        return false;
    }

    return true;
}

ping_message* Ping1D::waitMessage(enum PingMessageId id, uint16_t timeout_ms)
{
    uint32_t tstart = millis();
    while (millis() < tstart + timeout_ms) {

        ping_message* pmsg = read();

        if (!pmsg) {
            continue;
        }

        handleMessage(pmsg);

        if (pmsg->message_id() == static_cast<uint16_t>(PingMessageId::COMMON_NACK)) {
            common_nack nack(*pmsg);

            if (nack.nacked_id() == static_cast<uint16_t>(id)) {
                return nullptr;
            }
        }

        if (pmsg->message_id() == static_cast<uint16_t>(id)) {
            return pmsg;
        }
    }

    return nullptr;
}

void Ping1D::handleMessage(ping_message* pmsg)
{
    switch (static_cast<PingMessageId>(pmsg->message_id())) {
        case PingMessageId::PING1D_DEVICE_ID:
        {
            ping1d_device_id m(*pmsg);
            _device_id = m.device_id();
        }
            break;

        case PingMessageId::COMMON_DEVICE_INFORMATION:
        {
            common_device_information m(*pmsg);
            _device_type = m.device_type();
            _device_revision = m.device_revision();
            _firmware_version_major = m.firmware_version_major();
            _firmware_version_minor = m.firmware_version_minor();
            _firmware_version_patch = m.firmware_version_patch();
            _reserved = m.reserved();
        }
            break;

        case PingMessageId::PING1D_DISTANCE:
        {
            ping1d_distance m(*pmsg);
            _distance = m.distance();
            _confidence = m.confidence();
            _transmit_duration = m.transmit_duration();
            _ping_number = m.ping_number();
            _scan_start = m.scan_start();
            _scan_length = m.scan_length();
            _gain_setting = m.gain_setting();
        }
            break;

        case PingMessageId::PING1D_DISTANCE_SIMPLE:
        {
            ping1d_distance_simple m(*pmsg);
            _distance = m.distance();
            _confidence = m.confidence();
        }
            break;

        case PingMessageId::PING1D_FIRMWARE_VERSION:
        {
            ping1d_firmware_version m(*pmsg);
            _device_type = m.device_type();
            _device_model = m.device_model();
            _firmware_version_major = m.firmware_version_major();
            _firmware_version_minor = m.firmware_version_minor();
        }
            break;

        case PingMessageId::PING1D_GAIN_SETTING:
        {
            ping1d_gain_setting m(*pmsg);
            _gain_setting = m.gain_setting();
        }
            break;

        case PingMessageId::PING1D_GENERAL_INFO:
        {
            ping1d_general_info m(*pmsg);
            _firmware_version_major = m.firmware_version_major();
            _firmware_version_minor = m.firmware_version_minor();
            _voltage_5 = m.voltage_5();
            _ping_interval = m.ping_interval();
            _gain_setting = m.gain_setting();
            _mode_auto = m.mode_auto();
        }
            break;

        case PingMessageId::PING1D_MODE_AUTO:
        {
            ping1d_mode_auto m(*pmsg);
            _mode_auto = m.mode_auto();
        }
            break;

        case PingMessageId::PING1D_PCB_TEMPERATURE:
        {
            ping1d_pcb_temperature m(*pmsg);
            _pcb_temperature = m.pcb_temperature();
        }
            break;

        case PingMessageId::PING1D_PING_ENABLE:
        {
            ping1d_ping_enable m(*pmsg);
            _ping_enabled = m.ping_enabled();
        }
            break;

        case PingMessageId::PING1D_PING_INTERVAL:
        {
            ping1d_ping_interval m(*pmsg);
            _ping_interval = m.ping_interval();
        }
            break;

        case PingMessageId::PING1D_PROCESSOR_TEMPERATURE:
        {
            ping1d_processor_temperature m(*pmsg);
            _processor_temperature = m.processor_temperature();
        }
            break;

        case PingMessageId::PING1D_PROFILE:
        {
            ping1d_profile m(*pmsg);
            _distance = m.distance();
            _confidence = m.confidence();
            _transmit_duration = m.transmit_duration();
            _ping_number = m.ping_number();
            _scan_start = m.scan_start();
            _scan_length = m.scan_length();
            _gain_setting = m.gain_setting();
            if (m.profile_data_length() > _profile_data_length) {
                if (_profile_data) {
                    free(_profile_data);
                }
                _profile_data = (uint8_t*)malloc(m.profile_data_length() * sizeof(uint8_t));
            }

            _profile_data_length = m.profile_data_length();

            for (uint16_t i = 0; i < _profile_data_length; i++) {
                _profile_data[i] = m.profile_data()[i];
            }
        }
            break;

        case PingMessageId::COMMON_PROTOCOL_VERSION:
        {
            common_protocol_version m(*pmsg);
            _version_major = m.version_major();
            _version_minor = m.version_minor();
            _version_patch = m.version_patch();
            _reserved = m.reserved();
        }
            break;

        case PingMessageId::PING1D_RANGE:
        {
            ping1d_range m(*pmsg);
            _scan_start = m.scan_start();
            _scan_length = m.scan_length();
        }
            break;

        case PingMessageId::PING1D_SPEED_OF_SOUND:
        {
            ping1d_speed_of_sound m(*pmsg);
            _speed_of_sound = m.speed_of_sound();
        }
            break;

        case PingMessageId::PING1D_TRANSMIT_DURATION:
        {
            ping1d_transmit_duration m(*pmsg);
            _transmit_duration = m.transmit_duration();
        }
            break;

        case PingMessageId::PING1D_VOLTAGE_5:
        {
            ping1d_voltage_5 m(*pmsg);
            _voltage_5 = m.voltage_5();
        }
            break;


        default:
            break;
    }
}

// ex ping1d_voltage_5 msg(*pd.request(PingMessageId::PING1D_Voltage_5));
ping_message* Ping1D::request(enum PingMessageId id, uint16_t timeout_ms)
{
    static common_general_request msg;
    msg.set_requested_id(static_cast<uint16_t>(id));
    msg.updateChecksum();
    write(msg.msgData, msg.msgDataLength());
    return waitMessage(id, timeout_ms);
}

// ex auto msg = pd.request<ping1d_voltage_5>();
template <typename T>
T* Ping1D::request()
{
    T resp; // todo there should be some other (static) way to get the message id?
    static common_general_request req;
    req.set_requested_id(resp.message_id());
    req.updateChecksum();
    write(req.msgData, req.msgDataLength());
    return (T*)waitMessage(resp.message_id());
}

bool Ping1D::set_device_id(uint8_t device_id, bool verify)
{
    ping1d_set_device_id m;
    m.set_device_id(device_id);
    m.updateChecksum();
    write(m.msgData, m.msgDataLength());
    if (!request(PingMessageId::PING1D_DEVICE_ID)) {
        return false; // no reply from device
    }
    // Read back the data and check that changes have been applied
    if (verify
        && (_device_id != device_id)) {
        return false; // device reply does not match
    }
    return true; // success
}

bool Ping1D::set_gain_setting(uint8_t gain_setting, bool verify)
{
    ping1d_set_gain_setting m;
    m.set_gain_setting(gain_setting);
    m.updateChecksum();
    write(m.msgData, m.msgDataLength());
    if (!request(PingMessageId::PING1D_GAIN_SETTING)) {
        return false; // no reply from device
    }
    // Read back the data and check that changes have been applied
    if (verify
        && (_gain_setting != gain_setting)) {
        return false; // device reply does not match
    }
    return true; // success
}

bool Ping1D::set_mode_auto(uint8_t mode_auto, bool verify)
{
    ping1d_set_mode_auto m;
    m.set_mode_auto(mode_auto);
    m.updateChecksum();
    write(m.msgData, m.msgDataLength());
    if (!request(PingMessageId::PING1D_MODE_AUTO)) {
        return false; // no reply from device
    }
    // Read back the data and check that changes have been applied
    if (verify
        && (_mode_auto != mode_auto)) {
        return false; // device reply does not match
    }
    return true; // success
}

bool Ping1D::set_ping_enable(uint8_t ping_enabled, bool verify)
{
    ping1d_set_ping_enable m;
    m.set_ping_enabled(ping_enabled);
    m.updateChecksum();
    write(m.msgData, m.msgDataLength());
    if (!request(PingMessageId::PING1D_PING_ENABLE)) {
        return false; // no reply from device
    }
    // Read back the data and check that changes have been applied
    if (verify
        && (_ping_enabled != ping_enabled)) {
        return false; // device reply does not match
    }
    return true; // success
}

bool Ping1D::set_ping_interval(uint16_t ping_interval, bool verify)
{
    ping1d_set_ping_interval m;
    m.set_ping_interval(ping_interval);
    m.updateChecksum();
    write(m.msgData, m.msgDataLength());
    if (!request(PingMessageId::PING1D_PING_INTERVAL)) {
        return false; // no reply from device
    }
    // Read back the data and check that changes have been applied
    if (verify
        && (_ping_interval != ping_interval)) {
        return false; // device reply does not match
    }
    return true; // success
}

bool Ping1D::set_range(uint32_t scan_start, uint32_t scan_length, bool verify)
{
    ping1d_set_range m;
    m.set_scan_start(scan_start);
    m.set_scan_length(scan_length);
    m.updateChecksum();
    write(m.msgData, m.msgDataLength());
    if (!request(PingMessageId::PING1D_RANGE)) {
        return false; // no reply from device
    }
    // Read back the data and check that changes have been applied
    if (verify
        && (_scan_start != scan_start
        || _scan_length != scan_length)) {
        return false; // device reply does not match
    }
    return true; // success
}

bool Ping1D::set_speed_of_sound(uint32_t speed_of_sound, bool verify)
{
    ping1d_set_speed_of_sound m;
    m.set_speed_of_sound(speed_of_sound);
    m.updateChecksum();
    write(m.msgData, m.msgDataLength());
    if (!request(PingMessageId::PING1D_SPEED_OF_SOUND)) {
        return false; // no reply from device
    }
    // Read back the data and check that changes have been applied
    if (verify
        && (_speed_of_sound != speed_of_sound)) {
        return false; // device reply does not match
    }
    return true; // success
}

